import * as fs from 'fs';
import * as path from 'path';

import logger from '@docusaurus/logger';

import type {
  GetCategoryMetadataCategories,
  GetCategoryMetadataReturns,
  GetCategoryMetadataRouteBasePath,
  GetFooterLinksReturns,
  GetFooterLinksRouteBasePath,
  GetNavBarItemsReturns,
  GetNavBarItemsRouteBasePath,
  GetSidebarsReturns,
  GetSidebarsRouteBasePath,
} from './menu-builder.types.ts';

/**
 * Get category metadata.
 *
 * @param {GetCategoryMetadataRouteBasePath} routeBasePath - Route base path.
 *
 * @returns {GetCategoryMetadataReturns}
 *
 * @since 1.0.0
 */
export function getCategoryMetadata(routeBasePath: GetCategoryMetadataRouteBasePath): GetCategoryMetadataReturns {
  const fullBase = path.resolve(process.cwd(), routeBasePath);
  const categories: GetCategoryMetadataCategories = [];

  const entries = fs.readdirSync(fullBase, {
    withFileTypes: true,
  });

  for (const entry of entries) {
    // Skip non-directories.
    if (!entry.isDirectory()) {
      continue;
    }

    const folderName = entry.name;
    const metadataFile = path.join(fullBase, folderName, '_metadata_.json');

    // If metadata file does not exist, skip and show warning.
    if (!fs.existsSync(metadataFile)) {
      logger.warn(logger.interpolate`No metadata file found for folder: ${logger.path(folderName)}`);

      continue;
    }

    try {
      const raw = fs.readFileSync(metadataFile, 'utf8');
      const parsed = JSON.parse(raw);

      // Expect { name: string, position: number }
      if (
        parsed
        && typeof parsed.name === 'string'
        && typeof parsed.position === 'number'
      ) {
        categories.push({
          id: folderName,
          name: parsed.name,
          position: parsed.position,
          path: `${routeBasePath}/${folderName}/`,
        });
      } else {
        logger.error(logger.bold(`Invalid metadata file for folder: ${logger.path(folderName)}`));
      }
    } catch (error) {
      logger.error(logger.bold(`Failed to parse metadata file for folder: ${logger.path(folderName)}`));
    }
  }

  // Sort once at the end.
  categories.sort((a, b) => a.position - b.position);

  return categories.map((category) => ({
    id: category.id,
    name: category.name,
    path: category.path,
  }));
}

/**
 * Get footer links.
 *
 * @param {GetFooterLinksRouteBasePath} routeBasePath - Route base path.
 *
 * @returns {GetFooterLinksReturns}
 *
 * @since 1.0.0
 */
export function getFooterLinks(routeBasePath: GetFooterLinksRouteBasePath): GetFooterLinksReturns {
  logger.info(logger.interpolate`Fetching footer links from ${logger.path(routeBasePath)}...`);

  return getCategoryMetadata(routeBasePath).map((category) => ({
    label: category.name,
    to: category.path,
  }));
}

/**
 * Get nav bar items.
 *
 * @param {GetNavBarItemsRouteBasePath} routeBasePath - Route base path.
 *
 * @returns {GetNavBarItemsReturns}
 *
 * @since 1.0.0
 */
export function getNavBarItems(routeBasePath: GetNavBarItemsRouteBasePath): GetNavBarItemsReturns {
  logger.info(logger.interpolate`Fetching navigation bar items from ${logger.path(routeBasePath)}...`);

  return getCategoryMetadata(routeBasePath).map((category) => ({
    label: category.name,
    position: 'left',
    type: 'docSidebar',
    sidebarId: category.id,
  }));
}

/**
 * Get sidebars.
 *
 * @param {GetSidebarsRouteBasePath} routeBasePath - Route base path.
 *
 * @returns {GetSidebarsReturns}
 *
 * @since 1.0.0
 */
export function getSidebars(routeBasePath: GetSidebarsRouteBasePath): GetSidebarsReturns {
  logger.info(logger.interpolate`Fetching sidebars from ${logger.path(routeBasePath)}...`);

  return getCategoryMetadata(routeBasePath)
    .reduce<GetSidebarsReturns>((acc, category) => {
      acc[category.id] = [
        {
          type: 'autogenerated',
          dirName: category.id,
        },
      ];

      return acc;
    }, {});
}
