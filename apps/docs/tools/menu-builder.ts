import * as fs from 'fs';
import * as path from 'path';

import logger from '@docusaurus/logger';

import type {
  MenuBuilderGetCategoryMetadataCategories,
  MenuBuilderGetCategoryMetadataReturns,
  MenuBuilderGetCategoryMetadataRouteBasePath,
  MenuBuilderGetFooterLinksReturns,
  MenuBuilderGetFooterLinksRouteBasePath,
  MenuBuilderGetNavBarItemsReturns,
  MenuBuilderGetNavBarItemsRouteBasePath,
  MenuBuilderGetSidebarsReturns,
  MenuBuilderGetSidebarsRouteBasePath,
} from './types/menu-builder.d.ts';

/**
 * Menu builder.
 *
 * @since 1.0.0
 */
export class MenuBuilder {
  /**
   * Menu builder - Get footer links.
   *
   * @param {MenuBuilderGetFooterLinksRouteBasePath} routeBasePath - Route base path.
   *
   * @returns {MenuBuilderGetFooterLinksReturns}
   *
   * @since 1.0.0
   */
  public static getFooterLinks(routeBasePath: MenuBuilderGetFooterLinksRouteBasePath): MenuBuilderGetFooterLinksReturns {
    logger.info(logger.interpolate`Fetching footer links from ${logger.path(routeBasePath)}...`);

    return MenuBuilder.getCategoryMetadata(routeBasePath).map((category) => ({
      label: category.name,
      to: category.path,
    }));
  }

  /**
   * Menu builder - Get nav bar items.
   *
   * @param {MenuBuilderGetNavBarItemsRouteBasePath} routeBasePath - Route base path.
   *
   * @returns {MenuBuilderGetNavBarItemsReturns}
   *
   * @since 1.0.0
   */
  public static getNavBarItems(routeBasePath: MenuBuilderGetNavBarItemsRouteBasePath): MenuBuilderGetNavBarItemsReturns {
    logger.info(logger.interpolate`Fetching navigation bar items from ${logger.path(routeBasePath)}...`);

    return MenuBuilder.getCategoryMetadata(routeBasePath).map((category) => ({
      label: category.name,
      position: 'left',
      type: 'docSidebar',
      sidebarId: category.id,
    }));
  }

  /**
   * Menu builder - Get sidebars.
   *
   * @param {MenuBuilderGetSidebarsRouteBasePath} routeBasePath - Route base path.
   *
   * @returns {MenuBuilderGetSidebarsReturns}
   *
   * @since 1.0.0
   */
  public static getSidebars(routeBasePath: MenuBuilderGetSidebarsRouteBasePath): MenuBuilderGetSidebarsReturns {
    logger.info(logger.interpolate`Fetching sidebars from ${logger.path(routeBasePath)}...`);

    return MenuBuilder.getCategoryMetadata(routeBasePath)
      .reduce<MenuBuilderGetSidebarsReturns>((accumulated, category) => {
        return {
          ...accumulated,
          [category.id]: [
            {
              type: 'autogenerated',
              dirName: category.id,
            },
          ],
        };
      }, {});
  }

  /**
   * Menu builder - Get category metadata.
   *
   * @param {MenuBuilderGetCategoryMetadataRouteBasePath} routeBasePath - Route base path.
   *
   * @private
   *
   * @returns {MenuBuilderGetCategoryMetadataReturns}
   *
   * @since 1.0.0
   */
  private static getCategoryMetadata(routeBasePath: MenuBuilderGetCategoryMetadataRouteBasePath): MenuBuilderGetCategoryMetadataReturns {
    const fullBase = path.resolve(process.cwd(), routeBasePath);
    const categories: MenuBuilderGetCategoryMetadataCategories = [];

    const entries = fs.readdirSync(fullBase, {
      withFileTypes: true,
    });

    for (const entry of entries) {
      // Skip non-directories.
      if (!entry.isDirectory()) {
        continue;
      }

      const folderName = entry.name;
      const metadataFile = path.join(fullBase, folderName, '_metadata_.json');

      // If metadata file does not exist, skip and show warning.
      if (!fs.existsSync(metadataFile)) {
        logger.warn(logger.interpolate`No metadata file found for folder: ${logger.path(folderName)}`);

        continue;
      }

      try {
        const raw = fs.readFileSync(metadataFile, 'utf-8');
        const parsed = JSON.parse(raw);

        // Expect { name: string, position: number }
        if (
          parsed
          && typeof parsed.name === 'string'
          && typeof parsed.position === 'number'
        ) {
          categories.push({
            id: folderName,
            name: parsed.name,
            position: parsed.position,
            path: `${routeBasePath}/${folderName}/`,
          });
        } else {
          logger.error(logger.bold(`Invalid metadata file for folder: ${logger.path(folderName)}`));
        }
      } catch (error) {
        logger.error(logger.bold(`Failed to parse metadata file for folder: ${logger.path(folderName)}`));
      }
    }

    // Sort once at the end.
    categories.sort((a, b) => a.position - b.position);

    return categories.map((category) => ({
      id: category.id,
      name: category.name,
      path: category.path,
    }));
  }
}
